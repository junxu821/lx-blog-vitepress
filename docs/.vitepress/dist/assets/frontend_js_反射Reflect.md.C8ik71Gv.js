import{_ as s,c as e,o as a,a5 as i}from"./chunks/framework.Baw4MH5z.js";const f=JSON.parse('{"title":"反射Reflect","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/反射Reflect.md","filePath":"frontend/js/反射Reflect.md"}'),t={name:"frontend/js/反射Reflect.md"},l=i(`<h1 id="反射reflect" tabindex="-1">反射Reflect <a class="header-anchor" href="#反射reflect" aria-label="Permalink to &quot;反射Reflect&quot;">​</a></h1><h1 id="_1-反射存在的问题" tabindex="-1">1.反射存在的问题 <a class="header-anchor" href="#_1-反射存在的问题" aria-label="Permalink to &quot;1.反射存在的问题&quot;">​</a></h1><ul><li>代理中的this,有些方法属性依赖于目标对象的this,就会出问题</li><li>内部插槽,有的目标对象身上有,但是代理没有,就会出问题</li></ul><h1 id="_2-反射相比对象操作" tabindex="-1">2.反射相比对象操作 <a class="header-anchor" href="#_2-反射相比对象操作" aria-label="Permalink to &quot;2.反射相比对象操作&quot;">​</a></h1><p>反射与Object身上的同名方法相比较,反射更加细腻,往往不会抛出异常,而是会返回布尔值,显示当前操作的状态.</p><p><strong>状态标记</strong>的方法有:</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preventExtensions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setPrototypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h1 id="_3-可以替代一些操作符" tabindex="-1">3.可以替代一些操作符 <a class="header-anchor" href="#_3-可以替代一些操作符" aria-label="Permalink to &quot;3.可以替代一些操作符&quot;">​</a></h1><ol><li>Reflect.get():可以代替对象属性访问符</li><li>Reflect.set():可以替代=赋值运算符</li><li>Reflectct.has():可以替代in和with</li><li>Reflect.deleteProperty():可以替代delete运算符</li><li>Reflect.construct():可以替代new</li></ol><h1 id="_4-安全的使用函数" tabindex="-1">4.安全的使用函数 <a class="header-anchor" href="#_4-安全的使用函数" aria-label="Permalink to &quot;4.安全的使用函数&quot;">​</a></h1><p>通过函数的apply来调用函数,被调用的函数也定义了apply属性</p><p>解决方案:</p><p>1. Function.prototype.apply(myfunc,thisVal,arguments)</p><p><strong>代码太长</strong></p><p>2.可以通过Reflect.apply简洁的实现</p><p>Reflect.apply(myfunc,thisVal,arguments)</p>`,16),n=[l];function p(r,h,c,o,d,k){return a(),e("div",null,n)}const _=s(t,[["render",p]]);export{f as __pageData,_ as default};
