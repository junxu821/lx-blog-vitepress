import{_ as s,c as i,o as a,a5 as n}from"./chunks/framework.Baw4MH5z.js";const u=JSON.parse('{"title":"函数","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/函数.md","filePath":"frontend/js/函数.md"}'),l={name:"frontend/js/函数.md"},e=n(`<h1 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h1><h1 id="_1-定义函数的三种方式" tabindex="-1">1.定义函数的三种方式 <a class="header-anchor" href="#_1-定义函数的三种方式" aria-label="Permalink to &quot;1.定义函数的三种方式&quot;">​</a></h1><p>函数声明,函数表达式,构造函数new</p><h1 id="_2-箭头函数" tabindex="-1">2.箭头函数 <a class="header-anchor" href="#_2-箭头函数" aria-label="Permalink to &quot;2.箭头函数&quot;">​</a></h1><ol><li>不能使用arguments,super,new.target</li><li>不能作为构造函数</li><li>没有prototype属性</li></ol><h1 id="_3-函数名" tabindex="-1">3.函数名 <a class="header-anchor" href="#_3-函数名" aria-label="Permalink to &quot;3.函数名&quot;">​</a></h1><p>一个指向函数体的指针,所以函数可以相互赋值,有多个名字 函数有一个name的可读属性:</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> func4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> func1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func1.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func2.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func3.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func4.name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}).name)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().name)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h1 id="_4-参数" tabindex="-1">4.参数 <a class="header-anchor" href="#_4-参数" aria-label="Permalink to &quot;4.参数&quot;">​</a></h1><ul><li>可传可不传,行参个数和传的也没必要个数一样</li><li>可以通过伪数组arguments来访问</li><li>都是值传递,对象传的是引用地址</li><li>没有重载</li><li>重复定义,下面的会覆盖上面的定义</li><li>默认参数为undefined,也可以手动指定,是在调用时才起作用,定义时不起作用</li><li>箭头函数也可以用默认参数,不能省略括号</li></ul><h1 id="_5-参数作用域和暂时性死区" tabindex="-1">5.参数作用域和暂时性死区 <a class="header-anchor" href="#_5-参数作用域和暂时性死区" aria-label="Permalink to &quot;5.参数作用域和暂时性死区&quot;">​</a></h1><ul><li>参数作用域:就是参数有自己的作用域,不能引用函数体的变量</li><li>暂时性死区:根据参数的顺序,后面的默认参数可以引用前面的值,但是前面不能引用后面的</li></ul><h1 id="_6-es6的收集参数和arguments的区别" tabindex="-1">6.es6的收集参数和arguments的区别 <a class="header-anchor" href="#_6-es6的收集参数和arguments的区别" aria-label="Permalink to &quot;6.es6的收集参数和arguments的区别&quot;">​</a></h1><ol><li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li><li>arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。</li><li>arguments对象还有一些附加的属性 （如callee属性）。</li></ol><h1 id="_7-函数声明和函数表达式" tabindex="-1">7.函数声明和函数表达式 <a class="header-anchor" href="#_7-函数声明和函数表达式" aria-label="Permalink to &quot;7.函数声明和函数表达式&quot;">​</a></h1><p>是否有函数提升</p><h1 id="_8-函数内部的arguments-this-new-target" tabindex="-1">8.函数内部的arguments,this,new.target <a class="header-anchor" href="#_8-函数内部的arguments-this-new-target" aria-label="Permalink to &quot;8.函数内部的arguments,this,new.target&quot;">​</a></h1><p><strong>arguments</strong>:  属性callee:含义是指向当前arguments对象所在的函数    严格模式不能访问 <strong>this:</strong></p><ul><li><strong>普通函数</strong>:指的是当前<strong>调用</strong>该函数时的上下文对象,默认是全局上下文对象(网页环境中是window)</li><li><strong>箭头函数:<strong>指的是</strong>定义</strong>函数的上下文对象</li><li>caller:指的是当前调用当前函数的函数    func.caller   arguments.callee.caller:和func.caller结果是一样的   arguments.caller:严格模式不能访问,非严格是undefined,为了区分func.caller,且不能赋值</li></ul><h1 id="_9-函数的属性和方法" tabindex="-1">9.函数的属性和方法 <a class="header-anchor" href="#_9-函数的属性和方法" aria-label="Permalink to &quot;9.函数的属性和方法&quot;">​</a></h1><p>length:记录命名的形参个数 prototype:显示原型</p><h1 id="_10-尾调用优化" tabindex="-1">10.尾调用优化 <a class="header-anchor" href="#_10-尾调用优化" aria-label="Permalink to &quot;10.尾调用优化&quot;">​</a></h1><p><strong>含义:</strong></p><ul><li>没优化之前,每多一次嵌套函数,多一个栈帧</li><li>优化后,每次只存在一个栈帧 <strong>条件:</strong></li></ul><ol><li>严格模式下</li><li>外部函数的返回值是对尾调用函数的调用</li><li>尾调用函数执行完,不需要额外的操作</li><li>尾调用函数不涉及闭包</li></ol><h1 id="_11-iife" tabindex="-1">11.IIFE <a class="header-anchor" href="#_11-iife" aria-label="Permalink to &quot;11.IIFE&quot;">​</a></h1><p>可以模拟块级作用域</p><h2 id="_12-关于函数中的this" tabindex="-1">12.关于函数中的this： <a class="header-anchor" href="#_12-关于函数中的this" aria-label="Permalink to &quot;12.关于函数中的this：&quot;">​</a></h2><p>this关键字是函数运行时自动生成的一个内部对象，也被称作为环境对象，只能在函数内部使用。谁调用this，this就指向谁。谁调用我,我就指向谁</p><p>this的三种指向</p><ol><li>普通函数； 函数名() this指向window</li><li>对象方法: 对象名.方法名() this指向对象</li><li>构造函数； new 函数名() this指向new创建实例对象</li></ol>`,31),t=[e];function h(r,p,k,o,d,c){return a(),i("div",null,t)}const E=s(l,[["render",h]]);export{u as __pageData,E as default};
