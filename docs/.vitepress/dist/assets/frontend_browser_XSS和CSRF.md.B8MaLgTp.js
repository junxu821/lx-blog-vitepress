import{_ as e,c as r,o,a5 as t}from"./chunks/framework.DhzKnR-G.js";const l=JSON.parse('{"title":"XSS和CSRF","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/browser/XSS和CSRF.md","filePath":"frontend/browser/XSS和CSRF.md"}'),n={name:"frontend/browser/XSS和CSRF.md"},s=t('<h1 id="xss和csrf" tabindex="-1">XSS和CSRF <a class="header-anchor" href="#xss和csrf" aria-label="Permalink to &quot;XSS和CSRF&quot;">​</a></h1><p>【XSS】跨站脚本攻击</p><p>向有XSS漏洞的网站中注入恶意代码，用户访问该网站时，浏览器就会解析并执行恶意代码，能够获取用户的cookie等信息。分为反射型和存储型。存储型会将恶意代码保存到数据库，造成持久性的XSS攻击。</p><p>防范方法：将cookie设为http-only不能通过js代码获取cookie,</p><p>对用户的输入进行检查,对特殊字符进行过滤</p><p>【CSRF】跨站请求伪造</p><p>伪造用户身份恶意请求。比如用户访问了一个安全网站并且返回了cookie，在没有关闭浏览器标签的情况下，打开了恶意网站，恶意网站会带着用户的cookie向安全网站发出请求，经常出现于银行转账，购物情境下。</p><p>防范方法：检查http头部refer字段，查看请求是不是来在本站，使用验证码，请求加入token进行验证</p><p><strong>检查<strong><strong>Referer</strong></strong>字段</strong></p><p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p><p><strong>添加校验****token</strong></p><p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>',13),p=[s];function a(S,c,_,i,f,R){return o(),r("div",null,p)}const h=e(n,[["render",a]]);export{l as __pageData,h as default};
