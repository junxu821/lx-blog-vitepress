import{_ as e,c as r,o,a5 as t}from"./chunks/framework.DhzKnR-G.js";const l=JSON.parse('{"title":"Web Worker 和 webSocket","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/WebWorker和webSocket.md","filePath":"frontend/js/WebWorker和webSocket.md"}'),a={name:"frontend/js/WebWorker和webSocket.md"},k=t('<h1 id="web-worker-和-websocket" tabindex="-1">Web Worker 和 webSocket <a class="header-anchor" href="#web-worker-和-websocket" aria-label="Permalink to &quot;Web Worker 和 webSocket&quot;">​</a></h1><h1 id="worker-主线程" tabindex="-1">worker 主线程: <a class="header-anchor" href="#worker-主线程" aria-label="Permalink to &quot;worker 主线程:&quot;">​</a></h1><p>1.通过 worker = new Worker( url ) 加载一个 JS 文件来创建一个 worker，同时返回</p><p>一个 worker 实例。</p><p>2.通过 worker.postMessage( data ) 方法来向 worker 发开数</p><p>据。</p><p>3.绑定 worker.onmessage 方法来接收 worker 发开过来的数据。</p><p>4.可以使用</p><p>worker.terminate() 来终止一个 worker 的执行。</p><h1 id="websocket-是-web-应用程序的传输协议" tabindex="-1">WebSocket 是 Web 应用程序的传输协议， <a class="header-anchor" href="#websocket-是-web-应用程序的传输协议" aria-label="Permalink to &quot;WebSocket 是 Web 应用程序的传输协议，&quot;">​</a></h1><p>它提供了双向的，按序到达的数</p><p>据流。</p><p>他是一个 Html5 协议，WebSocket 的连接是持久的，他通过在客户</p><p>端和服务器之间保持双工连接，服务器的更新可以被及时推开给客户端，</p><p>而不需要客户端以一定时间间隔去轮询。</p>',15),c=[k];function s(n,p,b,w,_,d){return o(),r("div",null,c)}const h=e(a,[["render",s]]);export{l as __pageData,h as default};
