import{_ as a,c as t,o as p,a5 as e}from"./chunks/framework.DhzKnR-G.js";const S=JSON.parse('{"title":"JavaScript 的同源策略","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/JavaScript的同源策略.md","filePath":"frontend/js/JavaScript的同源策略.md"}'),r={name:"frontend/js/JavaScript的同源策略.md"},c=e('<h1 id="javascript-的同源策略" tabindex="-1">JavaScript 的同源策略 <a class="header-anchor" href="#javascript-的同源策略" aria-label="Permalink to &quot;JavaScript 的同源策略&quot;">​</a></h1><p>概念:同源策略是客户端脚本（尤其是 Javascript）的重要的安全度量标</p><p>准。它最早出自 Netscape Navigator2.0，其目的是防止某个文档或脚本</p><p>从多个不同源装载。</p><p>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全</p><p>协议。</p><p>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><p>为什么要有同源限制？</p><p>我们举例说明：比如一个黑客程序，他利用 Iframe 把真正的银行登录页</p><p>面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过 Javascript 读取到你的表单中 input 中的内容，这样用户名，</p><p>密码就轻松到手了。</p><p>缺点：</p><p>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。</p><p>这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中</p><p>间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>',15),_=[c];function s(i,o,n,d,v,f){return p(),t("div",null,_)}const m=a(r,[["render",s]]);export{S as __pageData,m as default};
