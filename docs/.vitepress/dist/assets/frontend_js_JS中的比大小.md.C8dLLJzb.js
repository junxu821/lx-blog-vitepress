import{_ as a,c as e,o as s,a5 as n}from"./chunks/framework.Baw4MH5z.js";const m=JSON.parse('{"title":"JS中的比大小","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/JS中的比大小.md","filePath":"frontend/js/JS中的比大小.md"}'),p={name:"frontend/js/JS中的比大小.md"},l=n(`<h1 id="js中的比大小" tabindex="-1">JS中的比大小 <a class="header-anchor" href="#js中的比大小" aria-label="Permalink to &quot;JS中的比大小&quot;">​</a></h1><h3 id="_1-都是数字" tabindex="-1">1. 都是数字 <a class="header-anchor" href="#_1-都是数字" aria-label="Permalink to &quot;1\\. 都是数字&quot;">​</a></h3><p>这个最简单了，我们直接进行数值比较就好了。JS 中数字类型（number）存储的方式只有一种，在其他语言中往往叫做双精度类型。算下来一共使用到了 64 个 bit（1 位符号位 + 11位指数位 + 52 位有效位），也就是 8 byte。但是浏览器可能会对整数的存储做一些优化，并不一定占用这么多。</p><h3 id="_2-都是字符串" tabindex="-1">2. 都是字符串 <a class="header-anchor" href="#_2-都是字符串" aria-label="Permalink to &quot;2\\. 都是字符串&quot;">​</a></h3><p>字符串的规则是逐个比较字符串中每个字符的编码，我们可以使用 <code>String</code> 内置的 <code>charCodeAt</code>来查看某个字符对应的编码。</p><div class="language-Plain vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Plain</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&quot;abc&quot;.charCodeAt(0)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>有个很容易犯的错误，大写的字母会比小写的字符编码小。所以 &#39;Banana&#39; 是小于 &#39;banana&#39;，大家在比较字符串大小的时候要把这一点额外考虑进去，如果这一点对你有影响的话，可以考虑把字符串全都小写化，再比较大小。</p><h3 id="_3-任意一个是数字" tabindex="-1">3. 任意一个是数字 <a class="header-anchor" href="#_3-任意一个是数字" aria-label="Permalink to &quot;3\\. 任意一个是数字&quot;">​</a></h3><p>优先把另外一个转为数字，应用规则 1。</p><h3 id="_4-任意一个是布尔值" tabindex="-1">4. 任意一个是布尔值 <a class="header-anchor" href="#_4-任意一个是布尔值" aria-label="Permalink to &quot;4\\. 任意一个是布尔值&quot;">​</a></h3><p>将其转为数值后，应用上面的规则。</p><h3 id="_5-某一个是对象" tabindex="-1">5. 某一个是对象 <a class="header-anchor" href="#_5-某一个是对象" aria-label="Permalink to &quot;5\\. 某一个是对象&quot;">​</a></h3><p>调用 <code>valueOf</code> 方法，取得的结果应用上面的几条规则进行比较；那如果没有 <code>valueOf</code> 呢？就调用 <code>toString</code>，取得的结果再按上面的规则进行比较。</p><p>比较操作符的规则就是上面这五条。</p><p>聪明的你可能发现了，在类型不相同的两个元素进行比较时，可能会包含隐式类型转化，这是个巨大的坑！</p><p>比如：<code>&#39;a&#39; &lt; 1</code> 和 <code>&#39;a&#39; &gt; 1</code> 结果都会返回 <code>false</code> ，这是因为我们会先应用规则 3，先想办法把字符串 &#39;a&#39; 转化为了数字类型，得到的结果是 <code>NaN</code> ，而 <code>NaN</code> 和谁比较都会返回 <code>false</code>。</p><p>这一点提醒我们，以后在比较大小时，最好只比较相同类型的变量，以免引发难以察觉到 BUG。 不过在全民 TypeScript 的时代，这一点也可以不用特别注意。</p><p>回归主题，我们的 Date 对象为什么能比较大小呢？因为 JS 帮我们重写了它的 <code>valueOf</code> 方法。它返回的结果是 Date 对象的毫秒表示，接下来我们就应用上述的规则 5 就好了。</p><div class="language-Plain vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Plain</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>new Date().valueOf() // 1610266969084</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>PS: 毫秒表示是当前 Date 对象表示的时间距离 UNIX 纪元（1970 年 1 月 1 日）差了多少毫秒。</p><div class="language-Plain vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Plain</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>new Date(&#39;2021-01-10&#39;) &lt; new Date(&#39;20201-01-11&#39;) </span></span>
<span class="line"><span>// 1610236800000 &lt; 1610323200000</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>依照这个原理，如果我们想让我们在自定义对象中实现大小的比较，直接重写 <code>valueOf</code> 方法就好了。</p><div class="language-Plain vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Plain</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>class AppleTree {</span></span>
<span class="line"><span>  constructor(age) {</span></span>
<span class="line"><span>      this.age = age</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  valueOf() {</span></span>
<span class="line"><span>      return this.age</span></span>
<span class="line"><span>  }    </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>new AppleTree(1) &lt; new AppleTree(10) // true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>比较 Date 对象只是个引子，通过它我们搞懂了 JS 中比较操作符的原理，再也不怕在这里踩坑了。</p>`,24),i=[l];function t(r,c,o,d,u,h){return s(),e("div",null,i)}const _=a(p,[["render",t]]);export{m as __pageData,_ as default};
