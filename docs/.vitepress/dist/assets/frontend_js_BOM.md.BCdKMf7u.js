import{_ as a,c as s,o as i,a5 as n}from"./chunks/framework.DhzKnR-G.js";const E=JSON.parse('{"title":"BOM","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/BOM.md","filePath":"frontend/js/BOM.md"}'),e={name:"frontend/js/BOM.md"},l=n(`<h1 id="bom" tabindex="-1">BOM <a class="header-anchor" href="#bom" aria-label="Permalink to &quot;BOM&quot;">​</a></h1><p>ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模型）</p><p>则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。多年来，</p><p>缺少事实上的规范导致 BOM 有很多问题，因为浏览器提供商会按照各自的想法随意去扩展它。W3C 为了把浏览器中</p><p>JavaScript 最基本的部分标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。</p><h1 id="window对象" tabindex="-1">window对象 <a class="header-anchor" href="#window对象" aria-label="Permalink to &quot;window对象&quot;">​</a></h1><p>BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色，</p><p>它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。</p><p>这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问 isNaN()、isFinite()、parseInt()、parseFloat() 等方法。</p><h1 id="全局变量与windows对象属性的差别" tabindex="-1">全局变量与windows对象属性的差别 <a class="header-anchor" href="#全局变量与windows对象属性的差别" aria-label="Permalink to &quot;全局变量与windows对象属性的差别&quot;">​</a></h1><p>抛开全局变量会成为 window 对象的属性不谈，定义全局变量与在 window 对象上直接定义属性还是有一点差别：</p><p>全局变量不能通过 delete 运算符删除，而直接在 window 对象上的定义的属性可以</p><h1 id="window-open-close方法" tabindex="-1">window.open()/close方法 <a class="header-anchor" href="#window-open-close方法" aria-label="Permalink to &quot;window.open()/close方法&quot;">​</a></h1><h2 id="_1-open方法" tabindex="-1">1.open方法 <a class="header-anchor" href="#_1-open方法" aria-label="Permalink to &quot;1.open方法&quot;">​</a></h2><p>可以接收4个参数：</p><ul><li>要加载的URL</li><li>窗口目标</li><li>一个特性字符串</li><li>一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值</li></ul><p>*** 后两个参数有很大的兼容性问题 ***</p><h2 id="_2-close-方法" tabindex="-1">2.close() 方法 <a class="header-anchor" href="#_2-close-方法" aria-label="Permalink to &quot;2.close() 方法&quot;">​</a></h2><p>仅适用于通过 window.open() 打开的弹出窗口。对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。</p><h1 id="定时器" tabindex="-1">定时器 <a class="header-anchor" href="#定时器" aria-label="Permalink to &quot;定时器&quot;">​</a></h1><p><em><strong>不建议传递字符串</strong></em></p><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> setTimeout(&quot;console.log(&#39;Hello world!&#39;) &quot;, 1000);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><em><strong>推荐的调用方式</strong></em></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() 的第二个参数告诉 JavaScript </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">再过多长时间把当前任务添加到队列中</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(添加的过程是异步的)。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h1 id="navigator对象" tabindex="-1">navigator对象 <a class="header-anchor" href="#navigator对象" aria-label="Permalink to &quot;navigator对象&quot;">​</a></h1><h1 id="location对象" tabindex="-1">location对象 <a class="header-anchor" href="#location对象" aria-label="Permalink to &quot;location对象&quot;">​</a></h1><p>location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是 document 对象的属性；</p><p>换句话说，window.location 和 document.location 引用的是同一个对象。</p><h1 id="history-对象" tabindex="-1">history 对象 <a class="header-anchor" href="#history-对象" aria-label="Permalink to &quot;history 对象&quot;">​</a></h1>`,29),t=[l];function o(p,r,h,d,c,k){return i(),s("div",null,t)}const b=a(e,[["render",o]]);export{E as __pageData,b as default};
