import{_ as a,c as r,o as t,a5 as e}from"./chunks/framework.Baw4MH5z.js";const b=JSON.parse('{"title":"js内置对象","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/js内置对象.md","filePath":"frontend/js/js内置对象.md"}'),o={name:"frontend/js/js内置对象.md"},n=e('<h1 id="js内置对象" tabindex="-1">js内置对象 <a class="header-anchor" href="#js内置对象" aria-label="Permalink to &quot;js内置对象&quot;">​</a></h1><h1 id="_1-math" tabindex="-1">1.Math <a class="header-anchor" href="#_1-math" aria-label="Permalink to &quot;1.Math&quot;">​</a></h1><p>Math是一个内置对象,而不是构造函数.</p><p><strong>(1)Math.fround()方法</strong></p><p>用于将一个数字转换为离它最近的单精度浮点数。调用Math.fround()方法的语法形式如下：</p><p>Math.fround(x);</p><p>其实在JavaScript中并不区分双精度浮点数和单精度浮点数，所有的数字都属于Number类型，而且所有的浮点数都是64位的。因此Math.fround()方法的实际执行过程如下：</p><p>1. 如果参数x不是Number类型的，那么先将它转换为Number类型；</p><p>2. 如果x是NaN，那么返回NaN；</p><p>3. 如果x是+0、-0、正无穷（+Infinity）或负无穷（-Infinity），那么返回x；</p><p>4. 将x转换为IEEE 754-2019标准的32位浮点数格式，转换过程中使用“舍入到偶数”策略，我们称这一步的结果为x32；</p><p>5. 将x32转换为IEEE 754-2019标准的64浮点数格式，我们称这一步的结果为x64；</p><p>6. 在具体的JavaScript实现中，返回和x64对应的Number类型的值。</p><p>如果某个数本身就能用单精度浮点数精确表示，那么Math.fround()方法的返回值还是它本身。但如果某个数不能用单精度浮点数格式精确表示，那么Math.fround()方法的返回值就可能是一个较接近但不相同的数；如果这个数在单精度浮点数范围之外（即它太过于大或太过于小），那么返回正无穷或负无穷。</p><p><strong>(2)random()和window.crypto.getRandomValues()</strong></p><p><em><strong>作用一样,后者随机性更高,做加密</strong></em></p><h1 id="_2-object" tabindex="-1">2.Object <a class="header-anchor" href="#_2-object" aria-label="Permalink to &quot;2.Object&quot;">​</a></h1><h1 id="_3-array" tabindex="-1">3.Array <a class="header-anchor" href="#_3-array" aria-label="Permalink to &quot;3.Array&quot;">​</a></h1><h1 id="_4-string" tabindex="-1">4.String <a class="header-anchor" href="#_4-string" aria-label="Permalink to &quot;4.String&quot;">​</a></h1><h1 id="_5-global" tabindex="-1">5.Global <a class="header-anchor" href="#_5-global" aria-label="Permalink to &quot;5.Global&quot;">​</a></h1><ul><li>isNaN(),isFinite(),parseInt(),parseFloat()都是Global的属性</li><li>undefined,NaN,Infinity都是Global的属性</li><li>原生引用类型的构造函数,Object,Function,Array,Boolean,String,Number,Date,RegExp,Symbol,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URLError等的构造函数都是Global的属性</li></ul><p>在浏览器的环境中,window是Global的代理,所以上面这些都是window的属性,window还实现了其他的东西,不光是Global</p>',22),i=[n];function l(s,d,p,h,c,_){return t(),r("div",null,i)}const f=a(o,[["render",l]]);export{b as __pageData,f as default};
